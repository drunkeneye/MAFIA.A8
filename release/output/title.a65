; ------------------------------------------------------------
; Mad Pascal Compiler version 1.7.2 [2025/02/06] for MOS 6502 CPU
; ------------------------------------------------------------

STACKWIDTH	= 16
CODEORIGIN	= $0C00

TRUE		= 1
FALSE		= 0
EOL		= $9B
__BUFFER	= $0400
@BUF		= __BUFFER

; ------------------------------------------------------------

	org $80

zpage

.if .def(@vbxe_detect)
fxptr	.ds 2						; VBXE pointer
.fi

.if .def(@AllocMem)||.def(MAIN.SYSTEM.GETMEM)||.def(MAIN.SYSTEM.FREEMEM)
psptr	.ds 2						; PROGRAMSTACK Pointer
.fi

bp	.ds 2
bp2	.ds 2
bp3	= bp+1

eax	.ds 4						;8 bytes (aex + edx) -> divREAL
edx	.ds 4
ecx	.ds 4

TMP
ztmp
ztmp8	.ds 1
ztmp9	.ds 1
ztmp10	.ds 1
ztmp11	.ds 1

STACKORIGIN	.ds STACKWIDTH*4
zpend

; ------------------------------------------------------------

ax	= eax
al	= eax
ah	= eax+1

cx	= ecx
cl	= ecx
ch	= ecx+1

dx	= edx
dl	= edx
dh	= edx+1

	org eax

FP1MAN0	.ds 1
FP1MAN1	.ds 1
FP1MAN2	.ds 1
FP1MAN3	.ds 1

	org edx

FP2MAN0	.ds 1
FP2MAN1	.ds 1
FP2MAN2	.ds 1
FP2MAN3	.ds 1

	org ecx

FPMAN0	.ds 1
FPMAN1	.ds 1
FPMAN2	.ds 1
FPMAN3	.ds 1

	org ztmp8

FP1SGN	.ds 1
FP1EXP	.ds 1

	org ztmp10

FP2SGN	.ds 1
FP2EXP	.ds 1

	org bp2

FPSGN	.ds 1
FPEXP	.ds 1

	.ifdef MAIN.@DEFINES.BASICOFF
	org CODEORIGIN
	icl 'atari\basicoff.asm'
	ini CODEORIGIN
	.fi

	.ifdef MAIN.@DEFINES.S_VBXE
	opt h-
	ins 'atari\s_vbxe\sdxld2.obx'
	opt h+
	.fi

	org CODEORIGIN

.local	MAIN.@RESOURCE
.endl

.local	RESOURCE
	icl 'atari\resource.asm'
	?EXTDETECT = 0
	?VBXDETECT = 0

	RCASM 'dlists/dlist_console.asm' DL_CONSOLE_ADR 0 0 0 0 0 0 0 0
	RCASM 'dlists/dlist_black_console.asm' DL_BLACK_CONSOLE_ADR 0 0 0 0 0 0 0 0
	RCASM 'dlists/dlist_logo.asm' DL_LOGO_ADR 0 0 0 0 0 0 0 0
	RCASM 'dlists/dlist_flags.asm' DL_MAP_ADR 0 0 0 0 0 0 0 0
.endl

; ------------------------------------------------------------

	org CODEORIGIN

	STATICDATA

; ------------------------------------------------------------

RTLIB
	icl 'rtl6502_a8.asm'

.print 'ZPAGE: ',zpage,'..',zpend-1

.print 'RTBUF: ',@buf,'..',@buf+255

.print 'RTLIB: ',RTLIB,'..',*-1

; ------------------------------------------------------------

START
	tsx
	stx MAIN.@halt+1

	.ifdef MAIN.@DEFINES.ROMOFF
	icl 'atari\romoff.asm'
	.fi

VLEN	= VARDATASIZE-VARINITSIZE
VADR	= DATAORIGIN+VARINITSIZE

	ift (VADR > $BFFF) && .not(.def MAIN.@DEFINES.ROMOFF)
	ert 'Invalid memory address range ',VADR
	eif

	ift (VLEN > 0) && (VLEN <= 256)
	ldx #256-VLEN
	lda #$00
	sta:rne VADR+VLEN-256,x+
	eli VLEN>256
	m@init
	eif

.ifdef psptr
	mwa #PROGRAMSTACK psptr
.fi

	ldx #$00					; X = 0
	stx bp						; BP = 0

	stx audctl					; reset POKEY
	stx audctl+$10
	lda #3
	sta skctl
	sta skctl+$10

	dex						; X = 255

	UNITINITIALIZATION

.local	MAIN						; PROCEDURE

	jmp l_00C7

; ------------------------------------------------------------

.local	SYSTEM						; UNIT

.local	DPEEK						; FUNCTION | ASSEMBLER | REGISTER

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta A
	lda :STACKORIGIN+STACKWIDTH,x
	sta A+1
	dex
@main

; -------------------  ASM Block 00000003  -------------------

	ldy #0
	mva (:edx),y Result
	iny
	mva (:edx),y Result+1

@exit

; ------------------------------------------------------------

; Push WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer

	inx
	mva RESULT :STACKORIGIN,x
	mva RESULT+1 :STACKORIGIN+STACKWIDTH,x

	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	eif

; ------------------------------------------------------------

A	= :EDX
RESULT	= :STACKORIGIN-4

	rts						; ret
.endl

.local	FILLCHAR					; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018000001810000188000

	.MACRO m@INLINE

; -------------------  ASM Block 00000028  -------------------

	jsr @fill

	.ENDM

; ------------------------------------------------------------

A	= :EDX
COUNT	= :ECX
VALUE	= :EAX

@exit
.endl
.endl							; overload

.local	MOVE						; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018100001880000188000

	.MACRO m@INLINE

; -------------------  ASM Block 00000034  -------------------

	jsr @move

	.ENDM

; ------------------------------------------------------------

SOURCE	= :EDX
DEST	= :ECX
COUNT	= :EAX

@exit
.endl
.endl							; overload

.local	MOVE						; PROCEDURE | ASSEMBLER | OVERLOAD | REGISTER | INLINE
.local	@03018100001880000300000

	.MACRO m@INLINE

; -------------------  ASM Block 00000036  -------------------

	jsr @move

	.ENDM

; ------------------------------------------------------------

SOURCE	= :EDX
DEST	= :ECX
COUNT	= :EAX

@exit
.endl
.endl							; overload

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; -------------------  ASM Block 00000060  -------------------

	.ifdef @CmdLine

	ldx #$0F
	mva:rpl $340,x IOCB@COPY,x-
	rts

IOCB@COPY	:16 brk
	eif


	rts

; ------------------------------------------------------------

M_PI_2	= $0648
D_PI_2	= $0192
D_PI_180	= $04
__PORTB_BANKS	= $0101
MGTIA	= $00
MVBXE	= $80
VBXE_XDLADR	= $00
VBXE_BCBTMP	= $E0
VBXE_BCBADR	= $0100
VBXE_MAPADR	= $1000
VBXE_CHBASE	= $1000
VBXE_OVRADR	= $5000
VBXE_WINDOW	= $B000
IDLI	= $00
IVBL	= $01
IVBLD	= $01
IVBLI	= $02
ITIM1	= $03
ITIM2	= $04
ITIM4	= $05
CH_DELCHR	= $FE
CH_ENTER	= $9B
CH_ESC	= $1B
CH_CURS_UP	= $1C
CH_CURS_DOWN	= $1D
CH_CURS_LEFT	= $1E
CH_CURS_RIGHT	= $1F
CH_TAB	= $7F
CH_EOL	= $9B
CH_CLR	= $7D
CH_BELL	= $FD
CH_DEL	= $7E
CH_DELLINE	= $9C
CH_INSLINE	= $9D
PAL_PMCOLOR0	= $00
PAL_PMCOLOR1	= $01
PAL_PMCOLOR2	= $02
PAL_PMCOLOR3	= $03
PAL_COLOR0	= $04
PAL_COLOR1	= $05
PAL_COLOR2	= $06
PAL_COLOR3	= $07
PAL_COLBAK	= $08
COLOR_BLACK	= $00
COLOR_WHITE	= $0E
COLOR_RED	= $32
COLOR_CYAN	= $96
COLOR_VIOLET	= $68
COLOR_GREEN	= $C4
COLOR_BLUE	= $74
COLOR_YELLOW	= $EE
COLOR_ORANGE	= $28
COLOR_BROWN	= $E4
COLOR_LIGHTRED	= $3C
COLOR_GRAY1	= $04
COLOR_GRAY2	= $06
COLOR_GRAY3	= $0A
COLOR_LIGHTGREEN	= $CC
COLOR_LIGHTBLUE	= $7C
FMOPENREAD	= $04
FMOPENWRITE	= $08
FMOPENAPPEND	= $09
FMOPENREADWRITE	= $0C
DATESEPARATOR	= DATAORIGIN+$0000
RND	= $D20A
adr.PALETTE	= $02C0
.var PALETTE	= adr.PALETTE .word
adr.HPALETTE	= $D012
.var HPALETTE	= adr.HPALETTE .word
FILEMODE	= DATAORIGIN+$0001
GRAPHMODE	= DATAORIGIN+$0002
IORESULT	= DATAORIGIN+$0003
EOLN	= DATAORIGIN+$0004
SCREENWIDTH	= DATAORIGIN+$0005
SCREENHEIGHT	= DATAORIGIN+$0007
adr.MEM	= $00
.var MEM	= adr.MEM .word
RNDSEED	= DATAORIGIN+$0009

.endl							; UNIT SYSTEM

; ------------------------------------------------------------

.local	ATARI						; UNIT

; ------------------------------------------------------------

DL_BLANK1	= $00
DL_BLANK2	= $10
DL_BLANK3	= $20
DL_BLANK4	= $30
DL_BLANK5	= $40
DL_BLANK6	= $50
DL_BLANK7	= $60
DL_BLANK8	= $70
DL_DLI	= $80
DL_LMS	= $40
DL_VSCROLL	= $20
DL_HSCROLL	= $10
DL_JMP	= $01
DL_JVB	= $41
DL_MODE_GR15	= $0E
DL_MODE_GR8	= $0F
IRQENS	= $10
RTCLOK	= $12
RTCLOK1	= $12
RTCLOK2	= $13
RTCLOK3	= $14
ATRACT	= $4D
LMARGIN	= $52
RMARGIN	= $53
ROWCRS	= $54
COLCRS	= $55
DINDEX	= $57
SAVMSC	= $58
PALNTS	= $62
RAMTOP	= $6A
VDSLST	= $0200
SDLSTL	= $0230
TXTROW	= $0290
TXTCOL	= $0291
TINDEX	= $0293
TXTMSC	= $0294
SDMCTL	= $022F
GPRIOR	= $026F
CRSINH	= $02F0
CHACT	= $02F3
CHBAS	= $02F4
CH	= $02FC
FILDAT	= $02FD
PCOLR0	= $02C0
PCOLR1	= $02C1
PCOLR2	= $02C2
PCOLR3	= $02C3
COLOR0	= $02C4
COLOR1	= $02C5
COLOR2	= $02C6
COLOR3	= $02C7
COLOR4	= $02C8
COLBAKS	= $02C8
HPOSP0	= $D000
HPOSP1	= $D001
HPOSP2	= $D002
HPOSP3	= $D003
HPOSM0	= $D004
HPOSM1	= $D005
HPOSM2	= $D006
HPOSM3	= $D007
SIZEP0	= $D008
SIZEP1	= $D009
SIZEP2	= $D00A
SIZEP3	= $D00B
SIZEM	= $D00C
GRAFP0	= $D00D
GRAFP1	= $D00E
GRAFP2	= $D00F
GRAFP3	= $D010
GRAFM	= $D011
P0PF	= $D004
PAL	= $D014
TRIG3	= $D013
COLPM0	= $D012
COLPM1	= $D013
COLPM2	= $D014
COLPM3	= $D015
COLPF0	= $D016
COLPF1	= $D017
COLPF2	= $D018
COLPF3	= $D019
COLBAK	= $D01A
COLBK	= $D01A
PRIOR	= $D01B
GRACTL	= $D01D
HITCLR	= $D01E
CONSOL	= $D01F
AUDF1	= $D200
AUDC1	= $D201
AUDF2	= $D202
AUDC2	= $D203
AUDF3	= $D204
AUDC3	= $D205
AUDF4	= $D206
AUDC4	= $D207
AUDCTL	= $D208
KBCODE	= $D209
IRQEN	= $D20E
SKSTAT	= $D20F
PORTA	= $D300
PORTB	= $D301
PACTL	= $D302
DMACTL	= $D400
CHACTL	= $D401
DLISTL	= $D402
HSCROL	= $D404
VSCROL	= $D405
PMBASE	= $D407
CHBASE	= $D409
WSYNC	= $D40A
VCOUNT	= $D40B
PENH	= $D40C
PENV	= $D40D
NMIEN	= $D40E
NMIVEC	= $FFFA
RESETVEC	= $FFFC
IRQVEC	= $FFFE

.endl							; UNIT ATARI

; ------------------------------------------------------------

.local	MATH						; UNIT

; ------------------------------------------------------------

.endl							; UNIT MATH

; ------------------------------------------------------------

.local	PMG						; UNIT

; ------------------------------------------------------------

_P_MAX	= $0E
_M0_MAX	= $02
_M1_MAX	= $00
_M2_MAX	= $03
_M3_MAX	= $04
_PM_NORMAL_SIZE	= $00
_PM_DOUBLE_SIZE	= $01
_PM_QUAD_SIZE	= $03
_PM_SHOW_ON	= $03
_PM_SHOW_OFF	= $00
_PM_DOUBLE_RES	= $01
_PM_SINGLE_RES	= $02
adr.P_DATA	= [DATAORIGIN+$000B] .array [4] .word
.var P_DATA	= adr.P_DATA .word
adr.M_DATA	= [DATAORIGIN+$0013] .array [4] .word
.var M_DATA	= adr.M_DATA .word
PM_MEM	= DATAORIGIN+$001B
PM_OFFSET	= DATAORIGIN+$001D
PM_TOP	= DATAORIGIN+$001F
PM_SIZE	= DATAORIGIN+$0020

.endl							; UNIT PMG

; ------------------------------------------------------------

.local	XBIOS						; UNIT

.local	XBIOSLOADFILE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000062  -------------------


    txa:pha
    mva #0 xBiosIOresult
    sta xBiosIOerror
    ldy filename
    ldx filename+1
    iny
    sne
    inx
    jsr xBIOS_LOAD_FILE
    bcc @+
    stx xBiosIOerror
    mva #1 xBiosIOresult 
@   pla:tax

; ------------------------------------------------------------

FILENAME	= DATAORIGIN+$0028

@VarData	= FILENAME
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	XBIOSOPENFILE					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000063  -------------------


    txa:pha
    mva #0 xBiosIOresult
    sta xBiosIOerror
    ldy filename
    ldx filename+1
    iny
    sne
    inx
    jsr xBIOS_OPEN_FILE
    bcc @+
    stx xBiosIOerror
    mva #1 xBiosIOresult 
@   pla:tax

; ------------------------------------------------------------

FILENAME	= DATAORIGIN+$002A

@VarData	= FILENAME
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	XBIOSLOADDATA					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000064  -------------------


    txa:pha
    mva #0 xBiosIOresult
    sta xBiosIOerror
    ldy dest
    ldx dest+1
    jsr xBIOS_LOAD_DATA
    bcc @+
    stx xBiosIOerror
    mva #1 xBiosIOresult 
@   pla:tax

; ------------------------------------------------------------

DEST	= DATAORIGIN+$002C

@VarData	= DEST
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

XBIOSIORESULT	= DATAORIGIN+$0022
XBIOSIOERROR	= DATAORIGIN+$0023
XBIOSDIRENTRYINDEX	= DATAORIGIN+$0024
XBIOSDIRENTRYSTATUS	= DATAORIGIN+$0025
XBIOSDIRENTRYSECTOR	= DATAORIGIN+$0026
XBIOS_ADDRESS	= $0800
XBIOS_VERSION	= $0802
XBIOS_RENAME_ENTRY	= $0803
XBIOS_LOAD_FILE	= $0806
XBIOS_OPEN_FILE	= $0809
XBIOS_LOAD_DATA	= $080C
XBIOS_WRITE_DATA	= $080F
XBIOS_OPEN_CURRENT_DIR	= $0812
XBIOS_GET_BYTE	= $0815
XBIOS_PUT_BYTE	= $0818
XBIOS_FLUSH_BUFFER	= $081B
XBIOS_SET_LENGTH	= $081E
XBIOS_SET_INIAD	= $0821
XBIOS_SET_FILE_OFFSET	= $0824
XBIOS_SET_RUNAD	= $0827
XBIOS_SET_DEFAULT_DEVICE	= $082A
XBIOS_OPEN_DIR	= $082D
XBIOS_LOAD_BINARY_FILE	= $0830
XBIOS_OPEN_DEFAULT_DIR	= $0833
XBIOS_SET_DEVICE	= $0836
XBIOS_RELOCATE_BUFFER	= $0839
XBIOS_GET_ENTRY	= $083C
XBIOS_OPEN_DEFAULT_FILE	= $083F
XBIOS_READ_SECTOR	= $0842
XBIOS_FIND_ENTRY	= $0845
XBIOS_SET_BUFFER_SIZE	= $0848
XDIRSIZE	= $0BE5
XSPEED	= $0BE6
XHSPEED	= $0BE7
XIRQEN	= $0BE8
XAUDCTL	= $0BE9
XFILE	= $0BEA
XDIR	= $0BEC
XIOV	= $0BEE
XBUFFERH	= $0BF0
XBUFSIZE	= $0BF1
XDAUX3	= $0BF2
XSEGMENT	= $0BF3
XNOTE	= $0BF5
XNOTEH	= $0BF7
XDEVICE	= $0BFC
XDCMD	= $0BFD
XDAUX1	= $0BFE
XDAUX2	= $0BFF

.endl							; UNIT XBIOS

; ------------------------------------------------------------

.local	CRT						; UNIT

; ------------------------------------------------------------

TEXTATTR	= DATAORIGIN+$002E
CONSOL	= $D01F
CN_START_SELECT_OPTION	= $00
CN_SELECT_OPTION	= $01
CN_START_OPTION	= $02
CN_OPTION	= $03
CN_START_SELECT	= $04
CN_SELECT	= $05
CN_START	= $06
CN_NONE	= $07
BLACK	= $00
WHITE	= $0F
RED	= $26
CYAN	= $AC
PURPLE	= $48
GREEN	= $B6
BLUE	= $86
YELLOW	= $DC
ORANGE	= $18
BROWN	= $F4
LIGHT_RED	= $2A
DARK_GREY	= $04
GREY	= $08
LIGHT_GREEN	= $BC
LIGHT_BLUE	= $9A
LIGHT_GREY	= $0C
BW40	= $00
CO40	= $01
BW80	= $02
CO80	= $03
MONO	= $07
C40	= $01
C80	= $03
BLINK	= $80

.endl							; UNIT CRT

; ------------------------------------------------------------

.local	CIO						; UNIT

; ------------------------------------------------------------

.endl							; UNIT CIO

; ------------------------------------------------------------

.local	APLIB						; UNIT

; ------------------------------------------------------------

.endl							; UNIT APLIB

; ------------------------------------------------------------

.local	B_UTILS						; UNIT

; ------------------------------------------------------------

BASE64CHARS	= DATAORIGIN+$002F
adr.BASE64INV	= [DATAORIGIN+$0031] .array [128]
.var BASE64INV	= adr.BASE64INV .word

.endl							; UNIT B_UTILS

; ------------------------------------------------------------

.local	MISC						; UNIT

.local	DETECTANTIC					; FUNCTION | ASSEMBLER

; -------------------  ASM Block 00000111  -------------------


// ANTIC PAL Test for Atari 8-bits
// (C) 2019 Guillermo Fuenzalida

antic_loop1
	lda vcount
	cmp #100
	bcc antic_loop1		// wait till scanline 200
	sta scanline
antic_loop2
	lda vcount
	cmp #10
	bmi antic_loop2_fin
	cmp scanline
	bmi antic_loop2
	sta scanline
	bpl antic_loop2

antic_loop2_fin
	ldy #$00
	lda #0
scanline equ *-1
	cmp #135
	bmi ntsc
	iny
ntsc
	sty Result


@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$00B1

	rts						; ret
.endl

; ------------------------------------------------------------

adr.BANKS	= $0101
.var BANKS	= adr.BANKS .word
DETECTOS	= $FFF7

.endl							; UNIT MISC

; ------------------------------------------------------------

.local	RMT						; UNIT

.local	TRMT.PLAY					; PROCEDURE | ASSEMBLER
	sta TRMT
	sty TRMT+1
	sta PLAYER
	sty PLAYER+1
	add #2
	scc
	iny
	sta MODUL
	sty MODUL+1

; -------------------  ASM Block 00000123  -------------------

	txa:pha

	asl ntsc		; =0 PAL, =4 NTSC
	bcc skp

	lda #%00000100
	sta ntsc

	bne quit
skp
	mwa TRMT adr+1

	ldy #1
adr	lda $ffff,y
	sta ptr+2

ptr	jsr $ff00		; jmp (TRMT)	6502 buggy indirect jump

quit	pla:tax

; ------------------------------------------------------------

TRMT	= DATAORIGIN+$00BB
PLAYER	= DATAORIGIN+$00BD
MODUL	= DATAORIGIN+$00BF

@VarData	= TRMT
@VarDataSize	= 6

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------
; ------------------------------------------------------------
@UnitInit

; optimize FAIL ('MISC.DETECTANTIC', RMT), line = 159

	jsr MISC.DETECTANTIC
	lda MISC.DETECTANTIC.RESULT
	jeq l_01D4

; optimize OK (RMT), line = 160

	lda #$00
	jmp l_01E2
l_01D4

; optimize OK (RMT), line = 162

	lda #$04
l_01E2
	sta NTSC

	rts

; ------------------------------------------------------------

NTSC	= DATAORIGIN+$00B2

.endl							; UNIT RMT

; ------------------------------------------------------------

.local	B_PMG						; UNIT

; ------------------------------------------------------------

PMG_VDELAY_M0	= $01
PMG_VDELAY_M1	= $02
PMG_VDELAY_M2	= $04
PMG_VDELAY_M3	= $08
PMG_VDELAY_P0	= $10
PMG_VDELAY_P1	= $20
PMG_VDELAY_P2	= $40
PMG_VDELAY_P3	= $80
PMG_SIZE_NORMAL	= $00
PMG_SIZE_X2	= $01
PMG_SIZE_X4	= $03
PMG_MSIZE0_X2	= $01
PMG_MSIZE0_X4	= $03
PMG_MSIZE1_X2	= $04
PMG_MSIZE1_X4	= $0C
PMG_MSIZE2_X2	= $10
PMG_MSIZE2_X4	= $30
PMG_MSIZE3_X2	= $40
PMG_MSIZE4_X4	= $C0
PMG_GRACTL_MISSILES	= $01
PMG_GRACTL_PLAYERS	= $02
PMG_GRACTL_LATCH	= $04
PMG_GRACTL_DEFAULT	= $03
PMG_SDMCTL_DMA_MISSILE	= $04
PMG_SDMCTL_DMA_PLAYER	= $08
PMG_SDMCTL_DMA_BOTH	= $0C
PMG_SDMCTL_ONELINE	= $10
PMG_SDMCTL_SCREEN_DISABLED	= $00
PMG_SDMCTL_SCREEN_NARROW	= $01
PMG_SDMCTL_SCREEN_NORMAL	= $02
PMG_SDMCTL_SCREEN_WIDE	= $03
PMG_SDMCTL_DEFAULT	= $0E
PMG_COLLISION_PLAYER_TO_P0	= $01
PMG_COLLISION_PLAYER_TO_P1	= $02
PMG_COLLISION_PLAYER_TO_P2	= $04
PMG_COLLISION_PLAYER_TO_P3	= $08
PMG_5PLAYER	= $10
PMG_OVERLAP	= $20
PMG_SDMCTL	= $D400
PMG_SDMCTL_S	= $022F
PMG_GPRIOR	= $D01B
PMG_GPRIOR_S	= $026F
PMG_PCOLR0	= $D012
PMG_PCOLR1	= $D013
PMG_PCOLR2	= $D014
PMG_PCOLR3	= $D015
adr.PMG_PCOLR	= $D012
.var PMG_PCOLR	= adr.PMG_PCOLR .word
PMG_PCOLR0_S	= $02C0
PMG_PCOLR1_S	= $02C1
PMG_PCOLR2_S	= $02C2
PMG_PCOLR3_S	= $02C3
adr.PMG_PCOLR_S	= $02C0
.var PMG_PCOLR_S	= adr.PMG_PCOLR_S .word
PMG_HPOS0	= $D000
PMG_HPOS1	= $D001
PMG_HPOS2	= $D002
PMG_HPOS3	= $D003
adr.PMG_HPOS	= $D000
.var PMG_HPOS	= adr.PMG_HPOS .word
PMG_HPOSM0	= $D004
PMG_HPOSM1	= $D005
PMG_HPOSM2	= $D006
PMG_HPOSM3	= $D007
adr.PMG_HPOSM	= $D004
.var PMG_HPOSM	= adr.PMG_HPOSM .word
PMG_SIZEP0	= $D008
PMG_SIZEP1	= $D009
PMG_SIZEP2	= $D00A
PMG_SIZEP3	= $D00B
adr.PMG_SIZEP	= $D008
.var PMG_SIZEP	= adr.PMG_SIZEP .word
PMG_SIZEM	= $D00C
PMG_GRAFP0	= $D00D
PMG_GRAFP1	= $D00E
PMG_GRAFP2	= $D00F
PMG_GRAFP3	= $D010
adr.PMG_GRAFP	= $D00D
.var PMG_GRAFP	= adr.PMG_GRAFP .word
PMG_GRAFM	= $D011
PMG_P0PL	= $D00C
PMG_P1PL	= $D00D
PMG_P2PL	= $D00E
PMG_P3PL	= $D00F
adr.PMG_PPL	= $D00C
.var PMG_PPL	= adr.PMG_PPL .word
PMG_VDELAY	= $D01C
PMG_GRACTL	= $D01D
PMG_HITCLR	= $D01E
PMG_PMBASE	= $D407
PMG_ONELINE	= DATAORIGIN+$00C5
PMG_BASE	= DATAORIGIN+$00C6
PMG_SIZE	= DATAORIGIN+$00C8

.endl							; UNIT B_PMG

; ------------------------------------------------------------

.local	DOS						; UNIT

; ------------------------------------------------------------

PALNTSC	= $D014

.endl							; UNIT DOS

; ------------------------------------------------------------

.local	STRUTILS					; UNIT

; ------------------------------------------------------------

.endl							; UNIT STRUTILS

; ------------------------------------------------------------

.local	SYSUTILS					; UNIT

; ------------------------------------------------------------

FAREADONLY	= $01
FAHIDDEN	= $02
FASYSFILE	= $04
FAVOLUMEID	= $08
FADIRECTORY	= $10
FAARCHIVE	= $20
FAANYFILE	= $3F

.endl							; UNIT SYSUTILS

; ------------------------------------------------------------

.local	B_SYSTEM					; UNIT

.local	SYSTEMOFF					; PROCEDURE | ASSEMBLER | OVERLOAD
.local	@010180000
	sta PORT_B

; -------------------  ASM Block 00000145  -------------------


		;lda:cmp:req 20 ;; removed due to problem with nmien = 0 already set
		sei
		mva #0 NMIEN

		mva port_b PORTB
		mwa #__nmi NMIVEC

		lda <__iret
		sta IRQVEC
		sta __vblvec
		sta __dlivec

		lda >__iret
		sta IRQVEC+1
		sta __vblvec+1
		sta __dlivec+1

		mva #$40 NMIEN
		sta __nmien
		bne __stop
__nmi
		bit NMIST
		bpl __vbl
		jmp __dlivec
.def :__dlivec = *-2
		rti
__vbl
		inc rtclok+2
		bne __vblvec-1
		inc rtclok+1
		bne __vblvec-1
		inc rtclok
		jmp __vblvec
.def :__vblvec = *-2
.def :__iret
    	rti
__stop

; ------------------------------------------------------------

PORT_B	= DATAORIGIN+$00CB

@VarData	= PORT_B
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	SYSTEMOFF					; PROCEDURE | OVERLOAD
.local	@00

; optimize OK (B_SYSTEM), line = 180

	lda #$FE
	jsr SYSTEMOFF.@010180000

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

.local	ENABLEDLI					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000152  -------------------


		lda:cmp:req 20
		mva #0 NMIEN
		mwa dliptr __dlivec
		mva #$c0 NMIEN
		sta __nmien

; ------------------------------------------------------------

DLIPTR	= DATAORIGIN+$00CC

@VarData	= DLIPTR
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WAITFRAME					; PROCEDURE | ASSEMBLER

; -------------------  ASM Block 00000154  -------------------


    lda:cmp:req rtclok+2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

; ------------------------------------------------------------

__NMIEN	= DATAORIGIN+$00CA
PORTB_SELFTEST_OFF	= $80
PORTB_BASIC_OFF	= $02
PORTB_SYSTEM_ON	= $01

.endl							; UNIT B_SYSTEM

; ------------------------------------------------------------

.local	B_CRT						; UNIT

.local	CRT_WRITE					; PROCEDURE | OVERLOAD
.local	@0101898600000100

; ------------------------------------------------------------

; Generate Assignment for WORD / SMALLINT / SHORTREAL / POINTER
; as Pointer
	lda :STACKORIGIN,x
	sta :bp2
	lda :STACKORIGIN+STACKWIDTH,x
	sta :bp2+1
	ldy #$00
	mva:rne (:bp2),y adr.S,y+
	dex
@main

; optimize OK (B_CRT), line = 531

	lda adr.S
	sta SYSTEM.MOVE.@03018100001880000300000.COUNT
	lda <adr.S+$01
	sta SYSTEM.MOVE.@03018100001880000300000.SOURCE
	lda >adr.S+$01
	sta SYSTEM.MOVE.@03018100001880000300000.SOURCE+1
	lda CRT_CURSOR
	sta SYSTEM.MOVE.@03018100001880000300000.DEST
	lda CRT_CURSOR+1
	sta SYSTEM.MOVE.@03018100001880000300000.DEST+1
	lda #$00
	sta SYSTEM.MOVE.@03018100001880000300000.COUNT+1
	.LOCAL +MAIN.SYSTEM.MOVE.@03018100001880000300000
	m@INLINE
	.ENDL

; optimize OK (B_CRT), line = 532

	lda adr.S
	add CRT_CURSOR
	sta CRT_CURSOR
	lda CRT_CURSOR+1
	adc #$00
	sta CRT_CURSOR+1

; ------------------------------------------------------------

adr.S	= [DATAORIGIN+$00D7] .array [256]
.var S	= adr.S .word

@VarData	= S
@VarDataSize	= 256

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
.endl							; overload

; ------------------------------------------------------------

DEFAULT_SCREENWIDTH	= $28
DEFAULT_SCREENHEIGHT	= $18
CHAR_RETURN	= $9B
CHAR_ESCAPE	= $1B
CHAR_BACKSPACE	= $7E
CHAR_TAB	= $7F
CHAR_INVERSE	= $81
CHAR_CAPS	= $82
ICHAR_RETURN	= $DB
ICHAR_ESCAPE	= $5B
ICHAR_BACKSPACE	= $7E
ICHAR_TAB	= $7F
ICHAR_INVERSE	= $C1
ICHAR_CAPS	= $C2
adr.CRT_KEYCODE	= CODEORIGIN+$00C3
.var CRT_KEYCODE	= adr.CRT_KEYCODE .word
CRT_VRAM	= DATAORIGIN+$00CE
CRT_SIZE	= DATAORIGIN+$00D0
CRT_SCREENWIDTH	= DATAORIGIN+$00D2
CRT_SCREENHEIGHT	= DATAORIGIN+$00D3
CRT_CURSOR	= DATAORIGIN+$00D4
CRT_LEFTMARGIN	= DATAORIGIN+$00D6
KBCODE	= $D209
CONSOL	= $D01F

.endl							; UNIT B_CRT

.local	MUSICPROXY					; PROCEDURE

; optimize OK (title.pas), line = 47

	lda PLAYMUSIC
	cmp #$01
	jne l_0264

; optimize FAIL ('RMT.TRMT.PLAY', title.pas), line = 48

	lda MSX
	ldy MSX+1
	jsr RMT.TRMT.PLAY
l_0264

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DLI_MAP						; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000157  -------------------


dli:
    phr ; store registers

dlijmp:
    jmp dli1

dli1:
    lda #>MAP_FNT_ADDRESS
    sta $D409 ; CHBAS_real
    sta WSYNC

    mva #$0e atari.colpf0 ; white 

    mva mapColorB atari.colpf1 ; $06 for map
    mva mapColorA atari.colpf2 ; $88 for map 
    mva #$2a atari.colpf3 ; orangish
    mva #$00 atari.colbk  ; black

    ; move PMG to current position
    lda spriteMoveDir
    cmp #$01
    beq dli1_X
    lda PLAYERPOS_X
    sec 
    sbc #$01
    jmp dli1_X2
dli1_X:
    lda PLAYERPOS_X
    ; clc
    ; adc #$01
dli1_X2:
    sta HPOSP0
    sta HPOSP1
    sta HPOSP2
    sta HPOSP3

    lda #<dli2
    sta dlijmp+1
    lda #>dli2
    sta dlijmp+2

    plr
    rti

dli2:
    nop
    nop
    nop
    nop
    mva #$00 atari.colpf2 ; hue
    mva #$ff atari.colpf1 ; lum

    lda #>MAINFONT_ADR
    sta $D409 ; CHBAS_real

    ; deactivate PMG by moving it out of screen
    lda #$0
    sta HPOSP0
    sta HPOSP1
    sta HPOSP2
    sta HPOSP3
    sta WSYNC

    ; next
    lda #<dli3
    sta dlijmp+1
    lda #>dli3
    sta dlijmp+2

    plr
    rti

dli3:
    sta WSYNC
    mva #$ff atari.colpf1 ; lum
    mva #$00 atari.colpf2 ; hue

    lda #<dli4
    sta dlijmp+1
    lda #>dli4
    sta dlijmp+2

    plr
    rti

dli4:
    jsr main.musicproxy

    lda #<dli1
    sta dlijmp+1
    lda #>dli1
    sta dlijmp+2

    plr
    rti


	rti						; ret
.endl

.local	DLI_BITMAP					; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000158  -------------------


dli:
    phr ; store registers

dlijmp:
    jmp dli1

dli1:
    lda #>MAP_FNT_ADDRESS
    sta $D409 ; CHBAS_real
    sta WSYNC

    mva #$0e atari.colpf0 ; white 
    mva mapColorB atari.colpf1 ; $06 for map
    mva mapColorA atari.colpf2 ; $88 for map 
    mva #$2a atari.colpf3 ; orangish
    mva #$00 atari.colbk  ; black

    lda #<dli2
    sta dlijmp+1
    lda #>dli2
    sta dlijmp+2

    plr
    rti

dli2:
    nop
    nop
    nop
    nop

    lda #>LOC_MAP_ADR
    sta $D409 ; CHBAS_real
    sta WSYNC

    jsr main.musicproxy

    lda #<dli1
    sta dlijmp+1
    lda #>dli1
    sta dlijmp+2

    plr
    rti


	rti						; ret
.endl

.local	DLI_BLACK_CONSOLE				; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000159  -------------------


    phr 
    mva #$0 atari.colpf0 
    mva #$0 atari.colpf1 
    mva #$0 atari.colpf2 
    mva #$0 atari.colbk 
    jsr main.musicproxy
    plr  

	rti						; ret
.endl

.local	DLI_CONSOLE					; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000160  -------------------


    phr  
    mva loccolbk atari.colbk
    mva loccolpf0 atari.colpf0 
    mva loccolpf1 atari.colpf1 
    mva loccolpf2 atari.colpf2  

    jsr main.musicproxy

    plr 

	rti						; ret
.endl

.local	XBUNAPL						; PROCEDURE

; optimize OK (xbaplib.pas), line = 13

	lda FNAME
	sta XBIOS.XBIOSOPENFILE.FILENAME
	lda FNAME+1
	sta XBIOS.XBIOSOPENFILE.FILENAME+1
	jsr XBIOS.XBIOSOPENFILE

; optimize OK (xbaplib.pas), line = 14

	lda OUTPUTPOINTER
	sta XBIOS.XBIOSLOADDATA.DEST
	lda OUTPUTPOINTER+1
	sta XBIOS.XBIOSLOADDATA.DEST+1
	jsr XBIOS.XBIOSLOADDATA

; ------------------------------------------------------------

FNAME	= DATAORIGIN+$01E5
OUTPUTPOINTER	= DATAORIGIN+$01E7

@VarData	= FNAME
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	WAITFRAMES					; PROCEDURE
	sta FRAMES

; --- WhileProlog
	jmp l_027C
l_027D

; optimize FAIL ('B_SYSTEM.WAITFRAME', console.pas), line = 10

	jsr B_SYSTEM.WAITFRAME

; optimize FAIL (0, console.pas), line = 11

	dec FRAMES
l_027C

; optimize OK (console.pas), line = 8

	lda FRAMES
	jne l_027D

; ------------------------------------------------------------

FRAMES	= DATAORIGIN+$01EA

@VarData	= FRAMES
@VarDataSize	= 1

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	BLACKCONSOLE					; PROCEDURE

; optimize OK (console.pas), line = 18

	lda CONSOLESTATE
	jeq @exit
l_02A4

; optimize OK (console.pas), line = 19

	lda <DLI_BLACK_CONSOLE
	sta B_SYSTEM.ENABLEDLI.DLIPTR
	lda >DLI_BLACK_CONSOLE
	sta B_SYSTEM.ENABLEDLI.DLIPTR+1
	jsr B_SYSTEM.ENABLEDLI

; optimize OK (console.pas), line = 20

	lda #$C8
	sta ATARI.DLISTL
	lda #$FF
	sta ATARI.DLISTL+1

; optimize OK (console.pas), line = 21

	lda #$00
	sta CONSOLESTATE

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	READKEYANDSTICK					; FUNCTION

; optimize OK (helpers_input.pas), line = 28

	lda #$00
	sta CH

; -------------------  ASM Block 00000161  -------------------


        phr
        lda #$00
        sta joystickused
  loop:
        lda $d300
        and #$0f
        cmp #$0f 
        bne foundstick

        lda $d010 ; try stick button 
        cmp #$00
        bne nofire 
        lda #$0c
        sta joystickused
        jmp loopend

nofire:
        lda consol		; START
        cmp #$05
        beq foundsave
        cmp #$03
        beq foundload
        cmp #$06
        beq foundmsx

        lda skctl		; ANY KEY
        and #$04
        bne loop

        lda kbcode
        jmp loopend
  stickdata:
        // right, left, down, up --> 7= 0111=right;  11=1011=left, 13=1101=down, 14=1110=up
        dta 0,0,0,0,    0,0, 0, 07,   0, 0,0, 06, 0,     15, 14
  foundstick:
        tay
        lda stickdata,y
        sta joystickused
        jmp loopend
  foundsave:
        lda #$1f 
        jmp loopend
  foundmsx:
        lda #$20
        jmp loopend
  foundload:
        lda #$1e
        // check for key
  loopend:
        sta ch
        plr
  
; optimize OK (helpers_input.pas), line = 82

	lda CH
	sta RESULT
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$01EB
CH	= DATAORIGIN+$01EC

@VarData	= CH
@VarDataSize	= 1

	rts						; ret
.endl

.local	CHECKKEYANDSTICK				; FUNCTION

; optimize OK (helpers_input.pas), line = 92

	lda #$00
	sta CH

; -------------------  ASM Block 00000162  -------------------


        phr

        lda $d300
        and #$0f
        cmp #$0f   
        bne foundstick

        lda $d010 ; try stick button 
        cmp #$00
        bne nofire 
        lda #$0c
        jmp loopend

  nofire:
        lda consol		; START
        and #1
        beq foundconsol

        lda skctl		; ANY KEY
        and #$04
        bne loopend_zero

        lda kbcode
        jmp loopend
  stickdata:
        dta 0,0,0,0,    0,0, 0, 07,   0, 0,0, 06, 0,     15, 14
  foundstick:
        tay
        lda stickdata,y
        jmp loopend
  foundconsol:
        // check for key
  loopend_zero:
        lda #$00
  loopend:
        sta ch
        plr
  
; optimize OK (helpers_input.pas), line = 132

	lda CH
	sta RESULT
@exit

; ------------------------------------------------------------

RESULT	= DATAORIGIN+$01ED
CH	= DATAORIGIN+$01EE

@VarData	= CH
@VarDataSize	= 1

	rts						; ret
.endl

.local	SHOW_LOGO					; PROCEDURE

; optimize OK (title.pas), line = 86

	lda D_LOGO
	sta XBUNAPL.FNAME
	lda D_LOGO+1
	sta XBUNAPL.FNAME+1
	lda #$36
	sta XBUNAPL.OUTPUTPOINTER
	lda #$90
	sta XBUNAPL.OUTPUTPOINTER+1
	jsr XBUNAPL

; optimize OK (title.pas), line = 87

	lda <DLI_CONSOLE
	sta B_SYSTEM.ENABLEDLI.DLIPTR
	lda >DLI_CONSOLE
	sta B_SYSTEM.ENABLEDLI.DLIPTR+1
	jsr B_SYSTEM.ENABLEDLI

; optimize OK (title.pas), line = 88

	lda #$80
	sta ATARI.DLISTL
	lda #$FC
	sta ATARI.DLISTL+1

; optimize OK (title.pas), line = 89

	lda #$12
	sta LOCCOLBK

; optimize OK (title.pas), line = 90

	lda #$9C
	sta LOCCOLPF0

; optimize OK (title.pas), line = 91

	sta LOCCOLPF1

; optimize OK (title.pas), line = 92

	lda #$12
	sta LOCCOLPF2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DLI_FLAGS					; PROCEDURE | ASSEMBLER | INTERRUPT

; -------------------  ASM Block 00000163  -------------------


dli:
    phr ; store registers

dlijmp:
    jmp dli1

dli1:
    lda #>MAP_FNT_ADDRESS
    sta $D409 ; CHBAS_real
    sta WSYNC
    // jsr $b006

    mva acolpf0 atari.colpf0 ; white
    mva acolpf1 atari.colpf1 ; red
    mva acolpf2 atari.colpf2 ; yellow
    mva acolpf3 atari.colpf3 ; blue
    mva acolbk atari.colbk  ; black

    lda #<dli1
    sta dlijmp+1
    lda #>dli1
    sta dlijmp+2

    plr
    rti


	rti						; ret
.endl

.local	COPYARROW					; PROCEDURE

; optimize OK (title.pas), line = 132

	lda #$D0
	sta OFS
	lda #$02
	sta OFS+1

; optimize OK (title.pas), line = 133

	lda #$09
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl (:bp2),y $C800,y-

; optimize OK (title.pas), line = 134

	lda #$31
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl (:bp2),y $C828,y-

; optimize OK (title.pas), line = 135

	lda #$1A
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl (:bp2),y $C850,y-

; optimize OK (title.pas), line = 136

	lda #$42
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl (:bp2),y $C878,y-

; ------------------------------------------------------------

OFS	= DATAORIGIN+$02B5

@VarData	= OFS
@VarDataSize	= 2

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DELARROW					; PROCEDURE
	sta CPOS

; optimize OK (title.pas), line = 142

	sta @CASETMP_0009
	cmp #$00
	jne l_0341
@

; optimize OK (title.pas), line = 143

	lda #$A0
	sta OFS
	lda #$00
	sta OFS+1
	jmp a_0009
l_0341
	cmp #$01
	jne l_034C

; optimize OK (title.pas), line = 144

	lda #$B8
	sta OFS
	lda #$01
	sta OFS+1
	jmp a_0009
l_034C
	cmp #$02
	jne l_0357

; optimize OK (title.pas), line = 145

	lda #$D0
	sta OFS
	lda #$02
	sta OFS+1
l_0357
a_0009

; optimize OK (title.pas), line = 147

	lda #$09
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	lda #$00
	ldy #$04
	sta:rpl (:bp2),y-

; optimize OK (title.pas), line = 148

	lda #$31
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	lda #$00
	ldy #$04
	sta:rpl (:bp2),y-

; optimize OK (title.pas), line = 149

	lda #$1A
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	lda #$00
	ldy #$04
	sta:rpl (:bp2),y-

; optimize OK (title.pas), line = 150

	lda #$42
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	lda #$00
	ldy #$04
	sta:rpl (:bp2),y-

; ------------------------------------------------------------

CPOS	= DATAORIGIN+$02B7
OFS	= DATAORIGIN+$02B8
@CASETMP_0009	= DATAORIGIN+$02BA

@VarData	= CPOS
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl

.local	DRAWARROW					; PROCEDURE
	sta CPOS

; optimize OK (title.pas), line = 156

	lda #$00
	jsr DELARROW

; optimize OK (title.pas), line = 157

	lda #$01
	jsr DELARROW

; optimize OK (title.pas), line = 158

	lda #$02
	jsr DELARROW

; optimize OK (title.pas), line = 159

	lda CPOS
	sta @CASETMP_000A
	jne l_03B1
@

; optimize OK (title.pas), line = 160

	lda #$A0
	sta OFS
	lda #$00
	sta OFS+1
	jmp a_000A
l_03B1
	cmp #$01
	jne l_03BC

; optimize OK (title.pas), line = 161

	lda #$B8
	sta OFS
	lda #$01
	sta OFS+1
	jmp a_000A
l_03BC
	cmp #$02
	jne l_03C7

; optimize OK (title.pas), line = 162

	lda #$D0
	sta OFS
	lda #$02
	sta OFS+1
l_03C7
a_000A

; optimize OK (title.pas), line = 164

	lda #$09
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl $C800,y (:bp2),y-

; optimize OK (title.pas), line = 165

	lda #$31
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl $C828,y (:bp2),y-

; optimize OK (title.pas), line = 166

	lda #$1A
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl $C850,y (:bp2),y-

; optimize OK (title.pas), line = 167

	lda #$42
	add OFS
	sta :bp2
	lda #$F4
	adc OFS+1
	sta :bp2+1
	ldy #$04
	mva:rpl $C878,y (:bp2),y-

; ------------------------------------------------------------

CPOS	= DATAORIGIN+$02BB
OFS	= DATAORIGIN+$02BC
@CASETMP_000A	= DATAORIGIN+$02BE

@VarData	= CPOS
@VarDataSize	= 4

@exit
	.ifdef @new
	lda <@VarData
	sta :ztmp
	lda >@VarData
	ldy #@VarDataSize-1
	jmp @FreeMem
	els
	rts						; ret
	eif
.endl
l_00C7

; optimize OK (title.pas), line = 179

	lda #$00
	sta PLAYMUSIC

; optimize OK (title.pas), line = 182

	cmp #$63
	jne l_0423

; optimize FAIL ('MUSICPROXY', title.pas), line = 183

	jsr MUSICPROXY
l_0423

; optimize OK (title.pas), line = 185

	lda #$22
	sta ATARI.DMACTL

; -------------------  ASM Block 00000164  -------------------


        pha
        jsr xbios.xBIOS_SET_DEFAULT_DEVICE
        lda #$00
        sta xbios.xIRQEN
        pla
    
; optimize FAIL ('B_SYSTEM.SYSTEMOFF.@00', title.pas), line = 195

	jsr B_SYSTEM.SYSTEMOFF.@00

; optimize OK (title.pas), line = 198

	lda $0800
	sta CS
	lda $0800+1
	sta CS+1

; optimize OK (title.pas), line = 199

	lda CS
	cmp #$78
	jne l_044Dx
	lda CS+1
	cmp #$42
	jeq l_044D
l_044Dx

; --- RepeatUntilProlog
l_044F

; optimize FAIL ('B_CRT.CRT_WRITE.@0101898600000100', title.pas), line = 202

	inx
	mva #$95 :STACKORIGIN,x
	mva #$0C :STACKORIGIN+STACKWIDTH,x
	jsr B_CRT.CRT_WRITE.@0101898600000100

; optimize OK (title.pas), line = 203

	jmp l_044F
l_044D

; optimize FAIL ('SHOW_LOGO', title.pas), line = 206

	jsr SHOW_LOGO

; optimize OK (title.pas), line = 207

	lda D_MPLAY
	sta XBUNAPL.FNAME
	lda D_MPLAY+1
	sta XBUNAPL.FNAME+1
	lda #$00
	sta XBUNAPL.OUTPUTPOINTER
	lda #$B0
	sta XBUNAPL.OUTPUTPOINTER+1
	jsr XBUNAPL

; optimize OK (title.pas), line = 208

	lda D_MUS
	sta XBUNAPL.FNAME
	lda D_MUS+1
	sta XBUNAPL.FNAME+1
	lda #$00
	sta XBUNAPL.OUTPUTPOINTER
	lda #$B8
	sta XBUNAPL.OUTPUTPOINTER+1
	jsr XBUNAPL

; optimize OK (title.pas), line = 210

	lda D_TITLE
	sta XBUNAPL.FNAME
	lda D_TITLE+1
	sta XBUNAPL.FNAME+1
	lda #$FA
	sta XBUNAPL.OUTPUTPOINTER
	lda #$2F
	sta XBUNAPL.OUTPUTPOINTER+1
	jsr XBUNAPL

; -------------------  ASM Block 00000165  -------------------

        lda #$70
        ldx #$00  ; low byte of music
        ldy #$b8  ; high byte
        jsr SAP_PLAYER_3
        lda #$00
        ldx #$00
        jsr SAP_PLAYER_3
    
; -------------------  ASM Block 00000166  -------------------

        jsr $6800
    
; -------------------  ASM Block 00000167  -------------------

        lda #$70
        ldx #$00  ; low byte of music
        ldy #$b8  ; high byte
        jsr SAP_PLAYER_3
        lda #$00
        ldx #$00
        jsr SAP_PLAYER_3
    
; optimize OK (title.pas), line = 239

	lda #$22
	sta ATARI.DMACTL

; optimize FAIL ('B_SYSTEM.SYSTEMOFF.@00', title.pas), line = 240

	jsr B_SYSTEM.SYSTEMOFF.@00

; optimize FAIL ('BLACKCONSOLE', title.pas), line = 241

	jsr BLACKCONSOLE

; optimize OK (title.pas), line = 243

	lda #$00
	sta SYSTEM.FILLCHAR.@03018000001810000188000.A
	lda #$F4
	sta SYSTEM.FILLCHAR.@03018000001810000188000.A+1
	lda #$C0
	sta SYSTEM.FILLCHAR.@03018000001810000188000.COUNT
	lda #$03
	sta SYSTEM.FILLCHAR.@03018000001810000188000.COUNT+1
	lda #$00
	sta SYSTEM.FILLCHAR.@03018000001810000188000.VALUE
	.LOCAL +MAIN.SYSTEM.FILLCHAR.@03018000001810000188000
	m@INLINE
	.ENDL

; optimize OK (title.pas), line = 244

	lda FLAGS_FNAME
	sta XBUNAPL.FNAME
	lda FLAGS_FNAME+1
	sta XBUNAPL.FNAME+1
	lda #$00
	sta XBUNAPL.OUTPUTPOINTER
	lda #$F0
	sta XBUNAPL.OUTPUTPOINTER+1
	jsr XBUNAPL

; optimize OK (title.pas), line = 246

	lda #$00
	sta CONSOLESTATE

; optimize OK (title.pas), line = 247

	lda #$0E
	sta ACOLPF0

; optimize OK (title.pas), line = 248

	lda #$24
	sta ACOLPF1

; optimize OK (title.pas), line = 249

	lda #$74
	sta ACOLPF2

; optimize OK (title.pas), line = 250

	lda #$1E
	sta ACOLPF3

; optimize OK (title.pas), line = 251

	lda #$00
	sta ACOLBK

; optimize OK (title.pas), line = 253

	lda <DLI_FLAGS
	sta B_SYSTEM.ENABLEDLI.DLIPTR
	lda >DLI_FLAGS
	sta B_SYSTEM.ENABLEDLI.DLIPTR+1
	jsr B_SYSTEM.ENABLEDLI

; optimize OK (title.pas), line = 254

	lda #$A0
	sta ATARI.DLISTL
	lda #$FF
	sta ATARI.DLISTL+1

; optimize OK (title.pas), line = 255

	lda #$00
	sta CPOS

; optimize FAIL ('COPYARROW', title.pas), line = 256

	jsr COPYARROW

; --- RepeatUntilProlog
l_0496

; optimize OK (title.pas), line = 258

	lda CPOS
	jsr DRAWARROW

; optimize FAIL ('READKEYANDSTICK', title.pas), line = 260

	jsr READKEYANDSTICK
	lda READKEYANDSTICK.RESULT
	sta CH

; optimize OK (title.pas), line = 261

	lda #$0A
	jsr WAITFRAMES

; --- RepeatUntilProlog
l_04A1

; optimize FAIL ('CHECKKEYANDSTICK', title.pas), line = 263

	jsr CHECKKEYANDSTICK
	lda CHECKKEYANDSTICK.RESULT
	sta TMPCH

; optimize OK (title.pas), line = 264

	cmp CH
	jeq l_04A1

; optimize OK (title.pas), line = 266

	lda CH
	cmp #$0C
	jne l_04C6
	jmp b_0496
l_04C6

; optimize OK (title.pas), line = 270

	lda CH
	cmp #$0E
	jne l_04DB

; optimize OK (title.pas), line = 272

	lda CPOS
	jeq l_04EE
	dec CPOS
l_04EE
l_04DB

; optimize OK (title.pas), line = 275

	lda CH
	cmp #$0F
	jne l_050F

; optimize OK (title.pas), line = 277

	lda CPOS
	add #$01
	sta :STACKORIGIN+9
	lda #$00
	adc #$00
	cmp #$00
	bne @+
	lda :STACKORIGIN+9
	cmp #$03
@
	jcs l_0526
	inc CPOS
l_0526
l_050F

; optimize OK (title.pas), line = 279

	jmp l_0496
b_0496

; optimize OK (title.pas), line = 281

	lda #$00
	sta TMPCOL

l_0543
; --- ForToDoCondition
	lda TMPCOL
	cmp #$08
	jcs l_0551

; optimize OK (title.pas), line = 283

	lda ACOLPF0
	and #$0F
	cmp #$01
	jcc l_0567
	jeq l_0567
	lda ACOLPF0
	sub #$02
	sta ACOLPF0
l_0567

; optimize OK (title.pas), line = 284

	lda ACOLPF1
	and #$0F
	cmp #$01
	jcc l_058A
	jeq l_058A
	lda ACOLPF1
	sub #$02
	sta ACOLPF1
l_058A

; optimize OK (title.pas), line = 285

	lda ACOLPF2
	and #$0F
	cmp #$01
	jcc l_05AD
	jeq l_05AD
	lda ACOLPF2
	sub #$02
	sta ACOLPF2
l_05AD

; optimize OK (title.pas), line = 286

	lda ACOLPF3
	and #$0F
	cmp #$01
	jcc l_05D0
	jeq l_05D0
	lda ACOLPF3
	sub #$02
	sta ACOLPF3
l_05D0

; optimize OK (title.pas), line = 287

	lda #$03
	jsr WAITFRAMES

; --- ForToDoEpilog
	inc TMPCOL
	jne l_0543
l_0551

; optimize OK (title.pas), line = 290

	lda #$00
	sta ACOLPF0

; optimize OK (title.pas), line = 291

	sta ACOLPF1

; optimize OK (title.pas), line = 292

	sta ACOLPF2

; optimize OK (title.pas), line = 293

	sta ACOLPF3

; optimize OK (title.pas), line = 295

	lda #$02
	sta CONSOLESTATE

; optimize FAIL ('BLACKCONSOLE', title.pas), line = 296

	jsr BLACKCONSOLE

; optimize OK (title.pas), line = 297

	lda #$FF
	sta ATARI.PORTB

; optimize OK (title.pas), line = 299

	lda CPOS
	sta @CASETMP_000B
	jne l_0608
@
	ldy #256-12
	mva:rne CODEORIGIN+$009F+12-256,y adr.FINALFNAME+12-256,y+
	jmp a_000B
l_0608
	cmp #$01
	jne l_060F
	ldy #256-12
	mva:rne CODEORIGIN+$00AB+12-256,y adr.FINALFNAME+12-256,y+
	jmp a_000B
l_060F
	cmp #$02
	jne l_0616
	ldy #256-12
	mva:rne CODEORIGIN+$00B7+12-256,y adr.FINALFNAME+12-256,y+
l_0616
a_000B

; optimize OK (title.pas), line = 304

	lda FINALFNAME
	sta XBIOS.XBIOSLOADFILE.FILENAME
	lda FINALFNAME+1
	sta XBIOS.XBIOSLOADFILE.FILENAME+1
	jsr XBIOS.XBIOSLOADFILE

; ------------------------------------------------------------

DUMMY_BE80	= $BE80
LOCATION_ADR	= $C000
TXT_ADDRESS	= $C800
MAINFONT_ADR	= $CC00
PMG_BASE_ADR	= $D800
MAP_FNT_ADDRESS	= $F000
MAP_SCR_ADDRESS	= $F400
LOC_MAP_ADR	= $F800
DL_BITMAP_ADR	= $FF00
DL_CONSOLE_ADR	= $FF80
DL_MAP_ADR	= $FFA0
DL_BLACK_CONSOLE_ADR	= $FFC8
XEX_ADDRESS	= $1FFA
SAP_PLAYER	= $B000
SAP_PLAYER_3	= $B003
SAP_PLAYER_6	= $B006
STICK	= $0278
PCOLR0	= $D012
PCOLR1	= $D013
PCOLR2	= $D014
PCOLR3	= $D015
PLAYERPOS_X	= DATAORIGIN+$01D7
SPRITEMOVEDIR	= DATAORIGIN+$01D8
JOYSTICKUSED	= DATAORIGIN+$01D9
MAPCOLORA	= DATAORIGIN+$01DA
MAPCOLORB	= DATAORIGIN+$01DB
ACOLPF0	= DATAORIGIN+$01DC
ACOLPF1	= DATAORIGIN+$01DD
ACOLPF2	= DATAORIGIN+$01DE
ACOLPF3	= DATAORIGIN+$01DF
ACOLBK	= DATAORIGIN+$01E0
PLAYMUSIC	= $E0A1
adr.MSX	= DATAORIGIN+$01E1	; [4] OBJECT
.var MSX	= adr.MSX .word
MSX.PLAYER	= DATAORIGIN+$01E1
MSX.MODUL	= DATAORIGIN+$01E3
CONSOLESTATE	= DATAORIGIN+$01E9
adr.D_LOGO	= $0C4D
.var D_LOGO	= adr.D_LOGO .word
adr.D_TITLE	= $0C59
.var D_TITLE	= adr.D_TITLE .word
adr.D_MPLAY	= $0C65
.var D_MPLAY	= adr.D_MPLAY .word
adr.D_MUS	= $0C71
.var D_MUS	= adr.D_MUS .word
adr.LOCFNAME	= [DATAORIGIN+$0273] .array [33]
.var LOCFNAME	= adr.LOCFNAME .word
adr.E7FNAME	= $0C7D
.var E7FNAME	= adr.E7FNAME .word
E7ADRM6	= $E5FA
ADR_LOGO	= $9036
ADR_LOGO_DL	= $9036
ADR_LOGO_GFX	= $9150
DL_LOGO_ADR	= $FC80
L_COLOR1	= $9C
L_COLOR2	= $12
LOCCOLBK	= $C918
LOCCOLPF0	= $C919
LOCCOLPF1	= $C91A
LOCCOLPF2	= $C91B
CPOS	= DATAORIGIN+$02BF
TMPCOL	= DATAORIGIN+$02C0
TMPDMACTL	= DATAORIGIN+$02C1
CS	= DATAORIGIN+$02C2
adr.FINALFNAME	= [DATAORIGIN+$02C4] .array [17]
.var FINALFNAME	= adr.FINALFNAME .word
adr.FLAGS_FNAME	= $0C89
.var FLAGS_FNAME	= adr.FLAGS_FNAME .word
CH	= DATAORIGIN+$02F6
TMPCH	= DATAORIGIN+$02F7
@CASETMP_000B	= DATAORIGIN+$02F8
@exit

@halt	ldx #$00
	txs

	.ifdef MAIN.@DEFINES.ROMOFF
	inc portb
	.fi

	ldy #$01

	rts

; ------------------------------------------------------------

.local	@DEFINES
ATARI
CART
CPU_6502
ROMOFF
NOROMFONT
BASICOFF
.endl

.local	@RESOURCE
.endl

.endl							; MAIN

; ------------------------------------------------------------
; ------------------------------------------------------------

.macro	UNITINITIALIZATION

	.ifdef MAIN.SYSTEM.@UnitInit
	jsr MAIN.SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.ATARI.@UnitInit
	jsr MAIN.ATARI.@UnitInit
	.fi

	.ifdef MAIN.MATH.@UnitInit
	jsr MAIN.MATH.@UnitInit
	.fi

	.ifdef MAIN.PMG.@UnitInit
	jsr MAIN.PMG.@UnitInit
	.fi

	.ifdef MAIN.XBIOS.@UnitInit
	jsr MAIN.XBIOS.@UnitInit
	.fi

	.ifdef MAIN.CRT.@UnitInit
	jsr MAIN.CRT.@UnitInit
	.fi

	.ifdef MAIN.CIO.@UnitInit
	jsr MAIN.CIO.@UnitInit
	.fi

	.ifdef MAIN.APLIB.@UnitInit
	jsr MAIN.APLIB.@UnitInit
	.fi

	.ifdef MAIN.B_UTILS.@UnitInit
	jsr MAIN.B_UTILS.@UnitInit
	.fi

	.ifdef MAIN.MISC.@UnitInit
	jsr MAIN.MISC.@UnitInit
	.fi

	.ifdef MAIN.RMT.@UnitInit
	jsr MAIN.RMT.@UnitInit
	.fi

	.ifdef MAIN.B_PMG.@UnitInit
	jsr MAIN.B_PMG.@UnitInit
	.fi

	.ifdef MAIN.DOS.@UnitInit
	jsr MAIN.DOS.@UnitInit
	.fi

	.ifdef MAIN.STRUTILS.@UnitInit
	jsr MAIN.STRUTILS.@UnitInit
	.fi

	.ifdef MAIN.SYSUTILS.@UnitInit
	jsr MAIN.SYSUTILS.@UnitInit
	.fi

	.ifdef MAIN.B_SYSTEM.@UnitInit
	jsr MAIN.B_SYSTEM.@UnitInit
	.fi

	.ifdef MAIN.B_CRT.@UnitInit
	jsr MAIN.B_CRT.@UnitInit
	.fi
.endm

; ------------------------------------------------------------

	ift .SIZEOF(MAIN.SYSTEM) > 0
	.print 'SYSTEM: ',MAIN.SYSTEM,'..',MAIN.SYSTEM+.SIZEOF(MAIN.SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.ATARI) > 0
	.print 'ATARI: ',MAIN.ATARI,'..',MAIN.ATARI+.SIZEOF(MAIN.ATARI)-1
	eif

	ift .SIZEOF(MAIN.MATH) > 0
	.print 'MATH: ',MAIN.MATH,'..',MAIN.MATH+.SIZEOF(MAIN.MATH)-1
	eif

	ift .SIZEOF(MAIN.PMG) > 0
	.print 'PMG: ',MAIN.PMG,'..',MAIN.PMG+.SIZEOF(MAIN.PMG)-1
	eif

	ift .SIZEOF(MAIN.XBIOS) > 0
	.print 'XBIOS: ',MAIN.XBIOS,'..',MAIN.XBIOS+.SIZEOF(MAIN.XBIOS)-1
	eif

	ift .SIZEOF(MAIN.CRT) > 0
	.print 'CRT: ',MAIN.CRT,'..',MAIN.CRT+.SIZEOF(MAIN.CRT)-1
	eif

	ift .SIZEOF(MAIN.CIO) > 0
	.print 'CIO: ',MAIN.CIO,'..',MAIN.CIO+.SIZEOF(MAIN.CIO)-1
	eif

	ift .SIZEOF(MAIN.APLIB) > 0
	.print 'APLIB: ',MAIN.APLIB,'..',MAIN.APLIB+.SIZEOF(MAIN.APLIB)-1
	eif

	ift .SIZEOF(MAIN.B_UTILS) > 0
	.print 'B_UTILS: ',MAIN.B_UTILS,'..',MAIN.B_UTILS+.SIZEOF(MAIN.B_UTILS)-1
	eif

	ift .SIZEOF(MAIN.MISC) > 0
	.print 'MISC: ',MAIN.MISC,'..',MAIN.MISC+.SIZEOF(MAIN.MISC)-1
	eif

	ift .SIZEOF(MAIN.RMT) > 0
	.print 'RMT: ',MAIN.RMT,'..',MAIN.RMT+.SIZEOF(MAIN.RMT)-1
	eif

	ift .SIZEOF(MAIN.B_PMG) > 0
	.print 'B_PMG: ',MAIN.B_PMG,'..',MAIN.B_PMG+.SIZEOF(MAIN.B_PMG)-1
	eif

	ift .SIZEOF(MAIN.DOS) > 0
	.print 'DOS: ',MAIN.DOS,'..',MAIN.DOS+.SIZEOF(MAIN.DOS)-1
	eif

	ift .SIZEOF(MAIN.STRUTILS) > 0
	.print 'STRUTILS: ',MAIN.STRUTILS,'..',MAIN.STRUTILS+.SIZEOF(MAIN.STRUTILS)-1
	eif

	ift .SIZEOF(MAIN.SYSUTILS) > 0
	.print 'SYSUTILS: ',MAIN.SYSUTILS,'..',MAIN.SYSUTILS+.SIZEOF(MAIN.SYSUTILS)-1
	eif

	ift .SIZEOF(MAIN.B_SYSTEM) > 0
	.print 'B_SYSTEM: ',MAIN.B_SYSTEM,'..',MAIN.B_SYSTEM+.SIZEOF(MAIN.B_SYSTEM)-1
	eif

	ift .SIZEOF(MAIN.B_CRT) > 0
	.print 'B_CRT: ',MAIN.B_CRT,'..',MAIN.B_CRT+.SIZEOF(MAIN.B_CRT)-1
	eif

.nowarn	.print 'CODE: ',CODEORIGIN,'..',MAIN.@RESOURCE-1

	ift .SIZEOF(MAIN.@RESOURCE)>0
.nowarn	.print 'RESOURCE: ',MAIN.@RESOURCE,'..',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE)-1
	eif

@end

.nowarn	.print 'VARS: ',MAIN.@RESOURCE+.SIZEOF(MAIN.@RESOURCE),'..',@end-1

; ------------------------------------------------------------

	?adr = *
	ift (?adr < ?old_adr) && (?old_adr - ?adr < $120)
	?adr = ?old_adr
	eif

	org ?adr
	?old_adr = *

DATAORIGIN
.by  $2D $0C $00 $00 $00 $28 $00 $18  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $02 $08  $80 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 <[CODEORIGIN+$0002]
.by  >[CODEORIGIN+$0002] $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $00 $00 $00 $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $1F $1C $1F $1E $1F $1E $1F  $1F $1E $1F $1E $1F $00 $00 $00
.by  $00 $00 $00 $00 $00 $00 $00 $00  $00 $00 $0E

VARINITSIZE	= *-DATAORIGIN
VARDATASIZE	= 761

PROGRAMSTACK	= DATAORIGIN+VARDATASIZE

	.print 'DATA: ',DATAORIGIN,'..',PROGRAMSTACK

	ert DATAORIGIN<@end,'DATA memory overlap'

	run START

; ------------------------------------------------------------

.macro	STATICDATA
.by  $00 $40 $41 $42 $43 $44 $45 $46  $47 $48 $49 $4A $4B $4C $4D $4E  $4F $50 $51 $52 $53 $54 $55 $56
.by  $57 $58 $59 $5A $61 $62 $63 $64  $65 $66 $67 $68 $69 $6A $6B $6C  $6D $6E $6F $70 $71 $72 $73 $74
.by  $75 $76 $77 $78 $79 $7A $30 $31  $32 $33 $34 $35 $36 $37 $38 $39  $2B $2F $04 $54 $52 $55 $45 $05
.by  $46 $41 $4C $53 $45 $0B $4C $4F  $47 $4F $20 $20 $20 $20 $41 $50  $4C $0B $54 $49 $54 $4C $45 $50
.by  $49 $43 $41 $50 $4C $0B $50 $4C  $41 $59 $42 $30 $30 $30 $41 $50  $4C $0B $54 $4D $55 $53 $42 $38
.by  $30 $30 $41 $50 $4C $0B $45 $37  $30 $30 $50 $41 $47 $45 $41 $50  $4C $0B $46 $4C $41 $47 $53 $42
.by  $4D $50 $41 $50 $4C $09 $2E $2F  $00 $38 $22 $29 $2F $33 $01 $0B  $4D $41 $49 $4E $50 $4C $20 $20
.by  $58 $45 $58 $0B $4D $41 $49 $4E  $45 $4E $20 $20 $58 $45 $58 $0B  $4D $41 $49 $4E $44 $45 $20 $20
.by  $58 $45 $58 $6C $6A $3B $FF $FF  $6B $2B $2A $6F $FF $70 $75 $9B  $69 $2D $3D $76 $FF $63 $FF $FF
.by  $62 $78 $7A $34 $FF $33 $36 $1B  $35 $32 $31 $2C $20 $2E $6E $FF  $6D $2F $81 $72 $FF $65 $79 $7F
.by  $74 $77 $71 $39 $FF $30 $37 $7E  $38 $3E $FF $66 $68 $64 $FF $82  $67 $73 $61 $4C $4A $3A $FF $FF
.by  $4B $5C $5E $4F $FF $50 $55 $FF  $49 $5F $7C $56 $FF $43 $FF $FF  $42 $58 $5A $24 $FF $23 $26 $FF
.by  $25 $22 $21 $5B $3B $5D $4E $FF  $4D $3F $FF $52 $FF $45 $59 $FF  $54 $57 $51 $28 $FF $29 $27 $FF
.by  $40 $FF $FF $46 $48 $44 $FF $FF  $47 $53 $41 $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF
.by  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF $FF $FF $FF $FF $FF  $FF $FF $FF
.endm

	end
